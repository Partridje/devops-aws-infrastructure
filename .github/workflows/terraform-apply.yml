name: Terraform Apply

on:
  # Disabled auto-deploy on push to prevent accidental infrastructure creation
  # Uncomment the lines below to enable automatic deployment on push to main
  # push:
  #   branches:
  #     - main
  #   paths:
  #     - 'terraform/**'
  #     - '.github/workflows/terraform-apply.yml'

  # Manual deployment only
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        type: choice
        options:
          - dev
          - prod

permissions:
  id-token: write  # Required for OIDC
  contents: read

env:
  AWS_REGION: eu-north-1
  TF_VERSION: 1.13.3

jobs:
  determine-environment:
    name: Determine Environment
    runs-on: ubuntu-latest
    outputs:
      environments: ${{ steps.set-env.outputs.environments }}
    steps:
      - name: Set environment
        id: set-env
        run: |
          # Only manual deployment is allowed
          echo "environments=[\"${{ github.event.inputs.environment }}\"]" >> $GITHUB_OUTPUT

  terraform-apply:
    name: Terraform Apply
    needs: determine-environment
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: ${{ fromJson(needs.determine-environment.outputs.environments) }}
      max-parallel: 1  # Deploy one environment at a time

    environment:
      name: ${{ matrix.environment }}
      url: ${{ steps.terraform-output.outputs.alb_url }}

    steps:
      #####################################
      # Checkout Code
      #####################################
      - name: Checkout repository
        uses: actions/checkout@v4

      #####################################
      # Configure AWS Credentials (OIDC)
      #####################################
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      #####################################
      # Setup Terraform
      #####################################
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false  # Required for output parsing

      #####################################
      # Terraform Init
      #####################################
      - name: Terraform Init
        working-directory: terraform/environments/${{ matrix.environment }}
        run: terraform init

      #####################################
      # Terraform Plan
      #####################################
      - name: Terraform Plan
        id: plan
        working-directory: terraform/environments/${{ matrix.environment }}
        run: |
          terraform plan -var='alert_email_addresses=["${{ secrets.ALERT_EMAIL_ADDRESSES }}"]' -out=tfplan
          terraform show -no-color tfplan > plan.txt

      - name: Upload Plan
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ matrix.environment }}-${{ github.sha }}
          path: |
            terraform/environments/${{ matrix.environment }}/tfplan
            terraform/environments/${{ matrix.environment }}/plan.txt
          retention-days: 30

      #####################################
      # Terraform Apply
      #####################################
      - name: Terraform Apply
        id: apply
        working-directory: terraform/environments/${{ matrix.environment }}
        run: terraform apply -auto-approve tfplan

      #####################################
      # Get Outputs
      #####################################
      - name: Terraform Output
        id: terraform-output
        working-directory: terraform/environments/${{ matrix.environment }}
        run: |
          echo "alb_url=$(terraform output -raw alb_url)" >> $GITHUB_OUTPUT
          echo "dashboard_url=$(terraform output -raw cloudwatch_dashboard_url)" >> $GITHUB_OUTPUT
          terraform output -json > outputs.json

      - name: Upload Outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs-${{ matrix.environment }}
          path: terraform/environments/${{ matrix.environment }}/outputs.json

      #####################################
      # Infrastructure Verification
      #####################################
      - name: Verify Infrastructure
        id: smoke-test
        run: |
          echo "Verifying infrastructure deployment..."

          # Check ALB exists and is active (search by name prefix)
          ALB_ARN=$(aws elbv2 describe-load-balancers \
            --query "LoadBalancers[?starts_with(LoadBalancerName, '${{ env.PROJECT_NAME }}-${{ matrix.environment }}-')].LoadBalancerArn" \
            --output text --region ${{ env.AWS_REGION }} | head -n1)

          if [ -z "$ALB_ARN" ]; then
            echo "::error::ALB not found for environment ${{ matrix.environment }}"
            exit 1
          fi

          ALB_STATE=$(aws elbv2 describe-load-balancers \
            --load-balancer-arns "$ALB_ARN" \
            --query "LoadBalancers[0].State.Code" \
            --output text --region ${{ env.AWS_REGION }})

          echo "ALB State: $ALB_STATE"

          if [ "$ALB_STATE" != "active" ]; then
            echo "::error::ALB is not active (state: $ALB_STATE)"
            exit 1
          fi

          # Check RDS exists and is available
          DB_STATUS=$(aws rds describe-db-instances \
            --query "DBInstances[?Tags[?Key=='Environment' && Value=='${{ matrix.environment }}']].DBInstanceStatus" \
            --output text --region ${{ env.AWS_REGION }} | head -n1)

          echo "RDS Status: $DB_STATUS"

          if [ "$DB_STATUS" != "available" ]; then
            echo "::warning::RDS is not yet available (status: $DB_STATUS)"
          fi

          # Check ASG exists
          ASG_NAME=$(aws autoscaling describe-auto-scaling-groups \
            --query "AutoScalingGroups[?Tags[?Key=='Environment' && Value=='${{ matrix.environment }}']].AutoScalingGroupName" \
            --output text --region ${{ env.AWS_REGION }} | head -n1)

          if [ -z "$ASG_NAME" ]; then
            echo "::error::ASG not found"
            exit 1
          fi

          echo "ASG Name: $ASG_NAME"

          echo "âœ“ Infrastructure verification completed successfully!"
          echo ""
          echo "NOTE: Application is not deployed yet. Run 'app-deploy' workflow to deploy the application."

      #####################################
      # Notify on Failure
      #####################################
      - name: Notify on failure
        if: failure()
        run: |
          echo "::error::Terraform apply failed for ${{ matrix.environment }}"
          echo "Check the logs and consider rolling back if necessary"

      #####################################
      # Job Summary
      #####################################
      - name: Create Job Summary
        if: always()
        run: |
          cat << EOF >> $GITHUB_STEP_SUMMARY
          ## Terraform Apply Summary

          **Environment:** \`${{ matrix.environment }}\`
          **Status:** ${{ job.status }}
          **Commit:** \`${{ github.sha }}\`
          **Actor:** @${{ github.actor }}

          ### Deployment Details
          - **ALB URL:** ${{ steps.terraform-output.outputs.alb_url }}
          - **Dashboard:** ${{ steps.terraform-output.outputs.dashboard_url }}

          ### Infrastructure Verification
          - Verification Status: ${{ steps.smoke-test.outcome }}

          ### Next Steps
          1. **Deploy Application:** Run \`app-deploy\` workflow for \`${{ matrix.environment }}\`
          2. Check CloudWatch dashboard for metrics
          3. Confirm SNS email subscription (if first deployment)
          4. Monitor logs at \`/aws/ec2/demo-app-${{ matrix.environment }}\`

          ---
          **Note:** Infrastructure is ready, but application is not deployed yet.
          You must run the \`app-deploy\` workflow to push Docker image to ECR and deploy the application.
          EOF
